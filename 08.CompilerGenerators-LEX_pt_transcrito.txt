===== Página 1 =====
18.Geradores de analisadores
8.1 Visão geral
8.2 Yacc
8.3 Lex
Compiladores
Versão reduzida/adaptada (original em http://dotnet.jku.at/courses/CC/)

===== Página 2 =====
2Como um gerador de compiladores trabalha
Eles geram partes de um compilador a partir de uma especificação
(partes geradas p.e. : scanner, parser, gerador de código, otimizador de árvores, ...)
gerador de 
compiladoresespecificação léxica
(p.e. expressões regulares)gerador de 
an. lexicosscanner
especificação sintática
(p.e. gram. de atributos)gerador de
an. sintáticoparser
classes de usuário
•tabela de símbolos
•gerador de código
•programa principal
•...compilador
& linkercompilador
gerado
Exemplos
Yacc gerador de an. sintáticos para C, C++ e  Java
Lex gerador de an. lexicos para C , Java e C#
Coco/R ger. de an. léxico e sintático para Java , C#, Modula -2, Oberon, ...
...

===== Página 3 =====
38.Geradores de analisadores
8.1 Visão geral
8.2 Yacc
8.3 Lex

===== Página 4 =====
4Lex —Gerador de analisadores léxicos
1975 desenvolvido nos laboratórios da Bell
•gera um an. léxico a partir de um AFD
•originalmente uma ferramenta Unix, atualmente versões para Windows
•originalmente para C , atualemente também para C++ e Java
•usualmente usado em conjunto com o YaccHistória
Principais versões atuais
flex versão GNU do Lex (for C)
http://www.gnu.org/software/flex/
JLex versão Java, contém algumas diferenças de sintaxe;
http://www.jflex.de/
CsLex versão C#, derivada de Jlex (http://www.cs.princeton.edu/~appel/modern/java/JLex/)
http://www.cybercom.net/~zbrad/DotNet/LexUso
sample.l Lex  sample.yy.c
C-Compiler sample.o sample.y Yacc sample.tab.cincludeExemplo de uso com o gerador para C

===== Página 5 =====
5Exemplo de escrição Lex 
%{ ... p.e. include directives para códgios de tokens exportados para o parser... %}
/* macros –opcional */
delim [  \t\n] /* blank, tab, eol */
ws {delim}+ /* {...} ... use of a macro */
letter [A-Za-z]
digit [0-9]
id {letter} ({letter} | {digit})*
number {digit}+
%%/* declaração de tokens descritos por expressões regulares*/
{ws} {} /* no action */
if { return IF; } /* constantes como IF são importadas do sintático */
then { return THEN;}
else { return ELSE; }
{id} { yylval = storeId(yytext, yyleng); return ID; }
{number} { yylval = convert(yytext, yyleng); return number; }
< { return yytext[0]; }
> { return yytext[0]; }
. {} /* "." Denota qualquer caracter */
%%/* rotinas semânticas */
int storeId(char* text, int len) {...}
int convert(char* text, int len) {...}

===== Página 6 =====
6Analisador gerado
A especificação léxica é traduzida em uma função
int yylex() {...}
que é incluída no sintático
yylex() também retorna atributos como variáveis globais (versão C)
int yylval; /* atributo se o tokem tem um valor numérico*/
char* yytext; /* texto do tokent (attributo de ident, string, ...) */
int yyleng; /* tamanho do texto do token */
int yylineno; /* número da linha do token*/
O sintático declara ( e exporta) os códigos dos tokens
%token IF
%token THEN
...

===== Página 7 =====
7Expressões regulares no Lex
Elementos das expressões regulares
abc a string "abc" ; cada caracter exceto ()[]{}*+?|^$. \denota o próprio caracter
. alquer caracter exceto \n(eol)
x* 0 ou mais repetições de x
x+ 1 ou mais repetições de x
x? 0 ou 1 ocorrência de x(opcional)
(...|...) para agrupar alternativas
[...] conjunto de todos os caracteres entre colchetes (p.e. [A-Za-z0-9$])
{...} uso de uma macro
^ início de linha; dentro do "[]" indica excessão
$ fim de linha
\udddd caracter in Unicode
Convenções
•o an. léxico reconhece o token com a maior sequência de possível de caracteres
(p.e. iffé reconhecido como IDe não como if)
•o an. léxico  verifica as declarações de tokens sequencialmente
(tokens declarados antes têm precedência sobre os seguintes)

