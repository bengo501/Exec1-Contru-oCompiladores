===== Página 1 =====
PUCRS – Escola Politécnica Construção de Compiladores                                        Ferramenta JFlex  (Adaptado do tutorial desenvolvido pelo prof. Júlio Machado)  O propósito deste texto é apresentar brevemente o gerador de analisadores léxicos JFlex, disponível em http://www.jflex.de/ (documentação: https://www.jflex.de/manual.pdf) e necessita do SDK do Java instalado para funcionar.  A tarefa do analisador léxico é verificar um código fonte e verificar se uma série de símbolos é válida ou não. Quando uma palavra é reconhecida como válida, diz-se que ela compõe um “token léxico”. Por exemplo:  • reconhecer “while” como uma palavra-chave; • reconhecer “1234” como um número inteiro; • identificar “#” como um símbolo inválido (para a linguagem Java).  O tipo de analisador léxico gerado pelo JFlex realiza um conjunto de tarefas mais avançadas do que retornar se uma série de símbolos é válida ou não. Ele é capaz de interagir com o analisador sintático, realizando as seguintes tarefas:  • reconhecer um token léxico e retornar ao analisador sintático um código que identifica o tipo de token; • repassar ao analisador léxico informações relacionadas ao token, como o texto da palavra reconhecida; • ativar código pré-definido pelo programador do analisador léxico.  A definição dos tokens válidos que serão reconhecidos pelo analisador léxico é através de uma linguagem regular. No caso do JFlex, será utilizado expressões regulares. O arquivo que contém as definições das expressões regulares é um arquivo texto com a extensão “.flex” e deve seguir o formato que será exemplificado mais adiante. A partir desse arquivo, o JFlex cria uma classe em Java que implementa o analisador léxico.  O processo de criação do analisador léxico consiste em criar um Autômato Finito Não-Determinístico com Movimento Vazio correspondente às expressões regulares. Após esse passo, o autômato é convertido para um Autômato Finito Determinístico. Por fim, é realizada a minimização do autômato obtido no passo anterior.  Instalação:  1. Fazer o download do programa JFlex. Acesse o site oficial ou baixe a cópia local disponibilizada na área Moodle da disciplina. 2. Copie o arquivo JFlex.jar para sua área de trabalho 3. Teste utilizando o comando:  java -jar JFlex.jar <especificação-léxica>

===== Página 2 =====
PUCRS – Escola Politécnica Construção de Compiladores                                        Ferramenta JFlex  4. (opcional) Abra o arquivo gerado (Yylex.java ou o nome definido na diretiva %class) e verifique o código java gerado. Tente identificar o local onde foram colocados seus códigos “de usuário”. 5. Compile o arquivo gerado via linha de comando ou qualquer IDE de desenvolvimento em Java. 6. Teste o analisador gerado utilizando o exemplo disponível na área Moodle.  As seguintes opções de geração de código estão disponíveis:  a. “pack” é a opção padrão e criar um código otimizado para o autômato via uma codificação da tabela de transições em strings. b. “table” implementa o autômato via uma tabela de transições em uma matriz. c. “switch” implementa o autômato via comandos switch case encadeados.  O arquivo de definição do JFlex possui basicamente três grandes seções (código do usuário, opções e declarações, regras léxicas) separadas por “%%”.  Seção de código do usuário  %%  Seção de opções e declarações  %%  Seção de regras léxicas   A seção de código do usuário contém código que será copiado sem alterações para a classe gerada pelo JFlex. Comandos package e import são colocados nesta seção.   A seção de opções e declarações contém opções de configuração do JFlex, declarações de código utilitário para o analisador léxico e macros para expressões regulares.  Cada opção de configuração deve começar em uma nova linha e iniciar com o símbolo “%”. Algumas configurações básicas:  • “%class nome_classe” permite configurar o nome da classe para o analisador léxico; se não está presente, será gerada a classe “Yylex”.  • “%line” ativa a contagem de linhas; o valor atual pode ser obtido através da variável yyline.  • “%column” ativa a contagem de colunas; o valor atual pode ser obtido através da variável yycolumn.

===== Página 3 =====
PUCRS – Escola Politécnica Construção de Compiladores                                        Ferramenta JFlex  • “%char” ativa a contagem de caracteres; o valor atual pode ser obtido através da variável yychar.  • “%full” entrada de dados em caracteres de 8bits.  • “%unicode” entrada de dados em caracteres de 16bits Unicode.  • “%standalone” cria um método main para o teste do analisador léxico via arquivos texto passados como parâmetros via linha de comando, retornando informações sobre o processamento na tela.  • “%cup” ativa o modo de compatibilidade com o gerador de analisadores sintáticos CUP.  • “%byacc” ativa o modo de compatibilidade com o gerador de analisadores sintáticos BYACC.  • “%state NOME_ESTADO” permite a definição de estados léxicos, os quais são utilizados para controlar com mais detalhe o funcionamento do analisador léxico. Um estado léxico age como uma condição inicial, de tal maneira que somente expressões regulares pertencentes ao estado atual serão reconhecidas (ver seção de regras léxicas mais adiante). O estado “YYINITIAL” é pré-definido e já está incluso.  Por exemplo, o código a seguir define que a contagem de linhas e caracteres está ativa, e que a entrada de dados será via caracteres de 8bits. Adicionalmente, será criado automaticamente um método main e o analisador léxico inicia no estado “COMMENT”.   %line %char %full %standalone %state COMMENT  Código em Java pode ser incluído nessa seção através dos marcadores “%{“ e “%}”, cada um em uma nova linha. Usualmente são declarados novos atributos e métodos utilitários. No exemplo, um atributo do tipo inteiro é criado como um contador do número de vezes que um marcador de comentário “/*” é aberto de forma encadeada.   %{  private int comment_count = 0;  %}

===== Página 4 =====
PUCRS – Escola Politécnica Construção de Compiladores                                        Ferramenta JFlex  A última parte desta seção termina com a declaração de macros para as expressões regulares. Macros são sinônimos utilizados para substituir uma expressão regular por um identificador mais simples. Para construir uma macro, utiliza-se  “IDENTIFICADOR_MACRO=EXPRESSAO_REGULAR”.  São elementos válidos para expressões regulares:  • Um caracter qualquer. o  “a” é a letra a o  “\n” é nova linha o “\xA9” é um número hexadecimal o “\u0001” é um caractere unicode o “\001” é um caractere ascii  • Um conjunto de caracteres pré-definidos. o “.” qualquer caractere menos nova-lina (“\n”) o “[:digit:]” dígitos o “[:letter:]” letras o “[:uppercase:]” caracteres maiúsculos o “[:lowercase:]” caracteres minúsculos  • Um conjunto de caracteres definidos pelo usuário “[]”; não existe caractere de separação na definição do conjunto. Intervalo entre caracteres utiliza-se o separador “-“. o “[0123456789]” é o conjunto de símbolos {0,1,2,3,4,5,6,7,8,9} o “[0-9]” idem o “[ ]” um espaço em branco  • Complemento de um conjunto de caracteres definidos pelo usuário “[^]”. o “[^\r\n]” qualquer caractere menos CR ou LF o “[^0-9]” qualquer caractere menos os dígitos de 0 a 9  • Uma palavra entre aspas duplas “"” o “"casa"” é a palavra casa.  • Uma macro de expressão regular “{nome_macro}”.    Sejam “a” e “b” duas expressões regulares, então pode-se utilizar um conjunto de operadores sobre elas:  • “a|b” é a união.  • “ab” é a concatenação.  • “a*” é a concatenação sucessiva de zero ou mais vezes.

===== Página 5 =====
PUCRS – Escola Politécnica Construção de Compiladores                                        Ferramenta JFlex  • “(a)” parênteses são utilizados para agrupar expressões e quebrar a precedência dos operadores.  • “a+” é a concatenação sucessiva de um ou mais vezes.  • “a?” é uma expressão alternativo (zero ou uma vez).  • “!a” é a negação (tudo menos a expressão indicada).  • “~a” é qualquer coisa até chegar à palavra denotada pela expressão.  • “a{n}” é concatenar n vezes.  • “a{n,m}” é concatenar no mínimo n vezes e no máximo m vezes.  No exemplo, tem-se as macros que definem um identificador válido na linguagem como uma sequência de símbolos que inicia por uma letra e segue com várias letras, dígitos ou sublinhado, e tem no mínimo tamanho um.  ALPHA=[A-Za-z] DIGIT=[0-9] Ident = {ALPHA}({ALPHA}|{DIGIT}|_)*  A seção de regras léxicas contém um conjunto de expressões regulares juntamente com código Java a ser executado toda vez que o analisador léxico reconhecer o token léxico definido pela expressão.  A forma geral de uma regra léxica é apresentada abaixo e deve ser interpretada de tal maneira que “EXPRESSÃO” é uma expressão regular que é reconhecida quando o analisador se encontra no estado léxico “ESTADO_CONDIÇÃO” e, quando reconhecida, dispara a execução do “CÓDIGO” associado. Se não é apresentado um estado na regra, então é pré-definido o estado como “YYINITIAL”.  <ESTADO_CONDIÇÃO> { EXPRESSÃO { CÓDIGO } EXPRESSÃO { CÓDIGO } }   Por exemplo, o fragmento de código a seguir reconhece constantes que são strings de caracteres, números inteiros ou identificadores de uma linguagem. No caso de uma string de caracteres, o código em Java associado cria um novo token léxico (um objeto da classe Yytoken) passando como parâmetro o código do token, seu conteúdo (a própria string de texto, obtida via o método auxiliar yytext()), o número da linha do código fonte, a posição de início na linha e a posição de fim na linha.

===== Página 6 =====
PUCRS – Escola Politécnica Construção de Compiladores                                        Ferramenta JFlex  <YYINITIAL> {  \"{STRING_TEXT}\" { String str = yytext().substring(1,yylength()-1); return new Yytoken(40,str,yyline,yychar,yychar+yylength()); }  {DIGIT}+ { return new Yytoken(42,yytext(),yyline,yychar,yychar+yylength()); }  {Ident} { return new Yytoken(43,yytext(),yyline,yychar,yychar+yylength());  }

